<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P2P 3D Multiplayer Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        
        #lobbyUI {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        #lobbyUI.hidden {
            display: none;
        }
        
        h1 {
            color: #667eea;
            margin-bottom: 20px;
            text-align: center;
            font-size: 24px;
        }
        
        h2 {
            color: #764ba2;
            margin: 20px 0 10px 0;
            font-size: 18px;
        }
        
        .section {
            margin-bottom: 25px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        
        input[type="text"] {
            width: 100%;
            padding: 10px;
            margin: 8px 0;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }
        
        textarea {
            width: 100%;
            padding: 10px;
            margin: 8px 0;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 12px;
            font-family: monospace;
            resize: vertical;
            min-height: 80px;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            width: 100%;
            margin: 5px 0;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            font-size: 14px;
            text-align: center;
            font-weight: bold;
        }
        
        .status.info {
            background: #d1ecf1;
            color: #0c5460;
        }
        
        .status.success {
            background: #d4edda;
            color: #155724;
        }
        
        .status.error {
            background: #f8d7da;
            color: #721c24;
        }
        
        #gameUI {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 16px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            pointer-events: none;
        }
        
        #gameUI.hidden {
            display: none;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
        }
        
        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: white;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
        }
        
        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
            top: 0;
        }
        
        #crosshair::after {
            width: 20px;
            height: 2px;
            left: 0;
            top: 9px;
        }
        
        .label {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="lobbyUI">
        <h1>ðŸŽ® P2P 3D Multiplayer</h1>
        
        <div class="section">
            <h2>Player Name</h2>
            <input type="text" id="playerName" placeholder="Enter your name" value="Player">
        </div>
        
        <div class="section">
            <h2>Host Game</h2>
            <button id="hostBtn">Create Game</button>
            <div class="label">Share this offer with your friend:</div>
            <textarea id="offerText" readonly placeholder="Click 'Create Game' to generate offer..."></textarea>
            <div class="label">Paste answer from friend here:</div>
            <textarea id="answerInput" placeholder="Paste answer here..."></textarea>
            <button id="connectHostBtn" disabled>Connect as Host</button>
        </div>
        
        <div class="section">
            <h2>Join Game</h2>
            <div class="label">Paste offer from host here:</div>
            <textarea id="offerInput" placeholder="Paste offer here..."></textarea>
            <button id="joinBtn">Join Game</button>
            <div class="label">Share this answer with host:</div>
            <textarea id="answerText" readonly placeholder="Click 'Join Game' after pasting offer..."></textarea>
        </div>
        
        <div id="statusMessage"></div>
    </div>
    
    <div id="gameUI" class="hidden">
        <div>Players Online: <span id="playerCount">1</span></div>
        <div>Controls: WASD - Move | Space - Jump | Click - Shoot</div>
    </div>
    
    <div id="crosshair" class="hidden"></div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ==================== GLOBAL STATE ====================
        const STUN_SERVERS = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };
        
        let peerConnection = null;
        let dataChannel = null;
        let isHost = false;
        let localPlayer = null;
        let remotePlayers = new Map();
        let scene, camera, renderer, ground;
        let keys = {};
        let playerName = 'Player';
        let gameStarted = false;
        let projectiles = [];
        
        // ==================== DOM ELEMENTS ====================
        const lobbyUI = document.getElementById('lobbyUI');
        const gameUI = document.getElementById('gameUI');
        const crosshair = document.getElementById('crosshair');
        const playerNameInput = document.getElementById('playerName');
        const hostBtn = document.getElementById('hostBtn');
        const joinBtn = document.getElementById('joinBtn');
        const connectHostBtn = document.getElementById('connectHostBtn');
        const offerText = document.getElementById('offerText');
        const offerInput = document.getElementById('offerInput');
        const answerText = document.getElementById('answerText');
        const answerInput = document.getElementById('answerInput');
        const statusMessage = document.getElementById('statusMessage');
        const playerCount = document.getElementById('playerCount');
        
        // ==================== UTILITY FUNCTIONS ====================
        function showStatus(message, type = 'info') {
            statusMessage.innerHTML = message;
            statusMessage.className = `status ${type}`;
        }
        
        function generateId() {
            return Math.random().toString(36).substr(2, 9);
        }
        
        // ==================== WEBRTC SIGNALING ====================
        async function createPeerConnection() {
            peerConnection = new RTCPeerConnection(STUN_SERVERS);
            
            peerConnection.onicecandidate = (event) => {
                // ICE candidates are included in the offer/answer
            };
            
            peerConnection.onconnectionstatechange = () => {
                console.log('Connection state:', peerConnection.connectionState);
                if (peerConnection.connectionState === 'connected') {
                    showStatus('Connected! Starting game...', 'success');
                    setTimeout(startGame, 1000);
                } else if (peerConnection.connectionState === 'disconnected' || 
                           peerConnection.connectionState === 'failed') {
                    showStatus('Connection lost', 'error');
                }
            };
            
            return peerConnection;
        }
        
        async function hostGame() {
            playerName = playerNameInput.value.trim() || 'Player';
            isHost = true;
            
            showStatus('Creating game...', 'info');
            hostBtn.disabled = true;
            
            await createPeerConnection();
            
            // Host creates the data channel
            dataChannel = peerConnection.createDataChannel('game');
            setupDataChannel();
            
            // Create offer
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            
            // Wait for ICE gathering to complete
            await new Promise((resolve) => {
                if (peerConnection.iceGatheringState === 'complete') {
                    resolve();
                } else {
                    peerConnection.addEventListener('icegatheringstatechange', () => {
                        if (peerConnection.iceGatheringState === 'complete') {
                            resolve();
                        }
                    });
                }
            });
            
            offerText.value = JSON.stringify(peerConnection.localDescription);
            connectHostBtn.disabled = false;
            showStatus('Share the offer with your friend, then paste their answer below', 'info');
        }
        
        async function connectAsHost() {
            const answerStr = answerInput.value.trim();
            if (!answerStr) {
                showStatus('Please paste the answer first', 'error');
                return;
            }
            
            try {
                const answer = JSON.parse(answerStr);
                await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
                showStatus('Connecting...', 'info');
                connectHostBtn.disabled = true;
            } catch (error) {
                showStatus('Invalid answer format', 'error');
                console.error(error);
            }
        }
        
        async function joinGame() {
            playerName = playerNameInput.value.trim() || 'Player';
            isHost = false;
            
            const offerStr = offerInput.value.trim();
            if (!offerStr) {
                showStatus('Please paste the offer first', 'error');
                return;
            }
            
            showStatus('Joining game...', 'info');
            joinBtn.disabled = true;
            
            try {
                await createPeerConnection();
                
                // Peer receives the data channel
                peerConnection.ondatachannel = (event) => {
                    dataChannel = event.channel;
                    setupDataChannel();
                };
                
                const offer = JSON.parse(offerStr);
                await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
                
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                
                // Wait for ICE gathering
                await new Promise((resolve) => {
                    if (peerConnection.iceGatheringState === 'complete') {
                        resolve();
                    } else {
                        peerConnection.addEventListener('icegatheringstatechange', () => {
                            if (peerConnection.iceGatheringState === 'complete') {
                                resolve();
                            }
                        });
                    }
                });
                
                answerText.value = JSON.stringify(peerConnection.localDescription);
                showStatus('Share the answer with the host', 'success');
            } catch (error) {
                showStatus('Invalid offer format', 'error');
                console.error(error);
                joinBtn.disabled = false;
            }
        }
        
        function setupDataChannel() {
            dataChannel.onopen = () => {
                console.log('Data channel opened');
                // Send initial handshake
                sendData({
                    type: 'handshake',
                    name: playerName,
                    id: localPlayer ? localPlayer.id : generateId()
                });
            };
            
            dataChannel.onmessage = (event) => {
                handleDataChannelMessage(JSON.parse(event.data));
            };
            
            dataChannel.onclose = () => {
                console.log('Data channel closed');
            };
        }
        
        function sendData(data) {
            if (dataChannel && dataChannel.readyState === 'open') {
                dataChannel.send(JSON.stringify(data));
            }
        }
        
        function handleDataChannelMessage(data) {
            switch (data.type) {
                case 'handshake':
                    createRemotePlayer(data.id, data.name);
                    // Send back our info
                    sendData({
                        type: 'handshake',
                        name: playerName,
                        id: localPlayer.id
                    });
                    updatePlayerCount();
                    break;
                    
                case 'position':
                    updateRemotePlayer(data.id, data);
                    break;
                    
                case 'shoot':
                    createRemoteProjectile(data);
                    break;
            }
        }
        
        // ==================== THREE.JS GAME SETUP ====================
        function initGame() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.Fog(0x87ceeb, 0, 300);
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            
            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 50, 25);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            scene.add(directionalLight);
            
            // Ground
            const groundGeometry = new THREE.PlaneGeometry(200, 200);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x4a7c59 });
            ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Add some visual elements to ground
            const gridHelper = new THREE.GridHelper(200, 40, 0x000000, 0x000000);
            gridHelper.material.opacity = 0.1;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);
            
            // Create local player
            localPlayer = createPlayer(generateId(), playerName, true);
            localPlayer.mesh.position.set(Math.random() * 10 - 5, 2, Math.random() * 10 - 5);
            
            // Input handlers
            document.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
            document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);
            document.addEventListener('click', shoot);
            
            // Handle window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
        
        function createPlayer(id, name, isLocal = false) {
            const player = {
                id: id,
                name: name,
                isLocal: isLocal,
                velocity: new THREE.Vector3(),
                rotation: 0,
                onGround: true
            };
            
            // Create player mesh (capsule-like shape)
            const bodyGeometry = new THREE.BoxGeometry(1, 2, 1);
            const bodyMaterial = new THREE.MeshLambertMaterial({ 
                color: isLocal ? 0x4488ff : 0xff4444 
            });
            player.mesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
            player.mesh.castShadow = true;
            player.mesh.receiveShadow = true;
            
            // Add head
            const headGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            const headMaterial = new THREE.MeshLambertMaterial({ 
                color: isLocal ? 0x5599ff : 0xff5555 
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.5;
            head.castShadow = true;
            player.mesh.add(head);
            
            scene.add(player.mesh);
            
            // Create name label
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            context.fillStyle = 'rgba(0, 0, 0, 0.6)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.font = 'Bold 32px Arial';
            context.fillStyle = 'white';
            context.textAlign = 'center';
            context.fillText(name, canvas.width / 2, 42);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            player.nameSprite = new THREE.Sprite(spriteMaterial);
            player.nameSprite.position.y = 3;
            player.nameSprite.scale.set(4, 1, 1);
            player.mesh.add(player.nameSprite);
            
            return player;
        }
        
        function createRemotePlayer(id, name) {
            if (!remotePlayers.has(id)) {
                const player = createPlayer(id, name, false);
                player.mesh.position.set(Math.random() * 10 - 5, 2, Math.random() * 10 - 5);
                player.targetPosition = player.mesh.position.clone();
                player.targetRotation = 0;
                remotePlayers.set(id, player);
            }
        }
        
        function updateRemotePlayer(id, data) {
            let player = remotePlayers.get(id);
            if (!player) {
                createRemotePlayer(id, data.name || 'Player');
                player = remotePlayers.get(id);
            }
            
            player.targetPosition = new THREE.Vector3(data.x, data.y, data.z);
            player.targetRotation = data.rotation;
        }
        
        function startGame() {
            lobbyUI.classList.add('hidden');
            gameUI.classList.remove('hidden');
            crosshair.classList.remove('hidden');
            gameStarted = true;
            
            if (!scene) {
                initGame();
            }
            
            updatePlayerCount();
            animate();
        }
        
        function updatePlayerCount() {
            playerCount.textContent = 1 + remotePlayers.size;
        }
        
        // ==================== GAME LOGIC ====================
        function updateLocalPlayer(delta) {
            if (!localPlayer) return;
            
            const moveSpeed = 10 * delta;
            const jumpForce = 8;
            const gravity = -20 * delta;
            
            // Movement
            const forward = new THREE.Vector3(0, 0, -1);
            const right = new THREE.Vector3(1, 0, 0);
            
            forward.applyAxisAngle(new THREE.Vector3(0, 1, 0), localPlayer.rotation);
            right.applyAxisAngle(new THREE.Vector3(0, 1, 0), localPlayer.rotation);
            
            if (keys['w']) localPlayer.mesh.position.add(forward.multiplyScalar(moveSpeed));
            if (keys['s']) localPlayer.mesh.position.add(forward.multiplyScalar(-moveSpeed));
            if (keys['a']) localPlayer.mesh.position.add(right.multiplyScalar(-moveSpeed));
            if (keys['d']) localPlayer.mesh.position.add(right.multiplyScalar(moveSpeed));
            
            // Rotation
            if (keys['q']) localPlayer.rotation += 2 * delta;
            if (keys['e']) localPlayer.rotation -= 2 * delta;
            
            // Jumping
            if (keys[' '] && localPlayer.onGround) {
                localPlayer.velocity.y = jumpForce;
                localPlayer.onGround = false;
            }
            
            // Apply gravity
            localPlayer.velocity.y += gravity;
            localPlayer.mesh.position.y += localPlayer.velocity.y * delta;
            
            // Ground collision
            if (localPlayer.mesh.position.y <= 2) {
                localPlayer.mesh.position.y = 2;
                localPlayer.velocity.y = 0;
                localPlayer.onGround = true;
            }
            
            // Keep player in bounds
            localPlayer.mesh.position.x = Math.max(-95, Math.min(95, localPlayer.mesh.position.x));
            localPlayer.mesh.position.z = Math.max(-95, Math.min(95, localPlayer.mesh.position.z));
            
            // Update mesh rotation
            localPlayer.mesh.rotation.y = localPlayer.rotation;
            
            // Update camera (third person)
            const cameraDistance = 8;
            const cameraHeight = 4;
            camera.position.x = localPlayer.mesh.position.x - Math.sin(localPlayer.rotation) * cameraDistance;
            camera.position.y = localPlayer.mesh.position.y + cameraHeight;
            camera.position.z = localPlayer.mesh.position.z - Math.cos(localPlayer.rotation) * cameraDistance;
            camera.lookAt(localPlayer.mesh.position);
            
            // Send position update
            if (dataChannel && dataChannel.readyState === 'open') {
                sendData({
                    type: 'position',
                    id: localPlayer.id,
                    name: localPlayer.name,
                    x: localPlayer.mesh.position.x,
                    y: localPlayer.mesh.position.y,
                    z: localPlayer.mesh.position.z,
                    rotation: localPlayer.rotation
                });
            }
        }
        
        function updateRemotePlayers(delta) {
            remotePlayers.forEach(player => {
                // Smooth interpolation
                if (player.targetPosition) {
                    player.mesh.position.lerp(player.targetPosition, 10 * delta);
                }
                
                // Smooth rotation
                if (player.targetRotation !== undefined) {
                    let rotDiff = player.targetRotation - player.mesh.rotation.y;
                    while (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
                    while (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
                    player.mesh.rotation.y += rotDiff * 10 * delta;
                }
            });
        }
        
        function shoot() {
            if (!gameStarted || !localPlayer) return;
            
            const projectile = {
                id: generateId(),
                position: localPlayer.mesh.position.clone(),
                position: new THREE.Vector3(
                    localPlayer.mesh.position.x,
                    localPlayer.mesh.position.y + 1,
                    localPlayer.mesh.position.z
                ),
                direction: new THREE.Vector3(
                    -Math.sin(localPlayer.rotation),
                    0,
                    -Math.cos(localPlayer.rotation)
                ),
                speed: 30,
                lifetime: 3,
                age: 0
            };
            
            // Create projectile mesh
            const geometry = new THREE.SphereGeometry(0.2, 8, 8);
            const material = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            projectile.mesh = new THREE.Mesh(geometry, material);
            projectile.mesh.position.copy(projectile.position);
            scene.add(projectile.mesh);
            
            projectiles.push(projectile);
            
            // Send shoot message
            sendData({
                type: 'shoot',
                x: projectile.position.x,
                y: projectile.position.y,
                z: projectile.position.z,
                dx: projectile.direction.x,
                dy: projectile.direction.y,
                dz: projectile.direction.z
            });
        }
        
        function createRemoteProjectile(data) {
            const projectile = {
                id: generateId(),
                position: new THREE.Vector3(data.x, data.y, data.z),
                direction: new THREE.Vector3(data.dx, data.dy, data.dz),
                speed: 30,
                lifetime: 3,
                age: 0
            };
            
            const geometry = new THREE.SphereGeometry(0.2, 8, 8);
            const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            projectile.mesh = new THREE.Mesh(geometry, material);
            projectile.mesh.position.copy(projectile.position);
            scene.add(projectile.mesh);
            
            projectiles.push(projectile);
        }
        
        function updateProjectiles(delta) {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                
                proj.position.add(proj.direction.clone().multiplyScalar(proj.speed * delta));
                proj.mesh.position.copy(proj.position);
                proj.age += delta;
                
                // Remove old projectiles
                if (proj.age > proj.lifetime || proj.position.y < 0) {
                    scene.remove(proj.mesh);
                    projectiles.splice(i, 1);
                }
            }
        }
        
        // ==================== ANIMATION LOOP ====================
        let lastTime = performance.now();
        
        function animate() {
            if (!gameStarted) return;
            
            requestAnimationFrame(animate);
            
            const currentTime = performance.now();
            const delta = (currentTime - lastTime) / 1000;
            lastTime = currentTime;
            
            updateLocalPlayer(delta);
            updateRemotePlayers(delta);
            updateProjectiles(delta);
            
            renderer.render(scene, camera);
        }
        
        // ==================== EVENT LISTENERS ====================
        hostBtn.addEventListener('click', hostGame);
        joinBtn.addEventListener('click', joinGame);
        connectHostBtn.addEventListener('click', connectAsHost);
        
        // Allow starting solo
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !gameStarted) {
                playerName = playerNameInput.value.trim() || 'Player';
                startGame();
            }
        });
        
        // Initialize
        showStatus('Enter your name and create/join a game, or press Enter to play solo', 'info');
    </script>
</body>
</html>
