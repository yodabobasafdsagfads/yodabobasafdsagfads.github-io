<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Fixed 3D Multiplayer Game</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
html,body { height:100%; margin:0; background:#111; color:#ddd; font-family: Inter, Arial, sans-serif; }
#container { width:100%; height:100%; display:flex; flex-direction:column; }
canvas { display:block; width:100%; height:100%; }
#hud { position: absolute; left:12px; top:12px; z-index:10; background:rgba(0,0,0,0.25); padding:8px; border-radius:8px; }
#controls { position: absolute; right:12px; top:12px; z-index:10; width:320px; background:rgba(0,0,0,0.35); padding:10px; border-radius:8px; font-size:13px; }
#console { position: absolute; left:12px; bottom:12px; z-index:10; background:rgba(0,0,0,0.35); padding:10px; border-radius:8px; max-width:640px; max-height:220px; overflow:auto; font-size:13px; }
button, input, textarea { font-family:inherit; font-size:13px; }
.small { font-size:12px; padding:6px; }
label { display:block; margin:6px 0 3px; }
textarea { width:100%; height:70px; resize:vertical; background:#0b0b0b; color:#eee; border:1px solid #333; padding:6px; border-radius:4px; }
.row { display:flex; gap:6px; align-items:center; margin-top:6px; }
.muted { color:#aaa; font-size:12px; }
#netStatus { color:#f5c; font-weight:600; }
</style>
</head>
<body>
<div id="container"></div>

<div id="hud">
  <div><strong>Score</strong></div>
  <div id="score">You: 0</div>
  <div class="muted">WASD to move • Mouse to look • Click to shoot</div>
</div>

<div id="controls">
  <div style="display:flex;justify-content:space-between;align-items:center;">
    <div><strong>Controls & Multiplayer</strong></div>
    <div id="netStatus">offline</div>
  </div>

  <label>Local multiplayer</label>
  <div class="row">
    <button id="toggleSplit" class="small">Toggle Split-screen (Tab)</button>
    <button id="spawnBot" class="small">Spawn Bot</button>
  </div>

  <label style="margin-top:10px">Online (manual WebRTC signaling)</label>
  <div class="row">
    <button id="createOffer" class="small">Create Offer</button>
    <button id="createAnswer" class="small">Create Answer</button>
  </div>

  <label>Local Offer / Paste from remote</label>
  <textarea id="localOffer" placeholder="Offer or Answer text"></textarea>

  <label>Remote Offer (paste if answering)</label>
  <textarea id="remoteOffer" placeholder="Paste remote offer here"></textarea>

  <label>Remote Answer (paste if you created offer)</label>
  <textarea id="remoteAnswer" placeholder="Paste remote answer here"></textarea>

  <div class="row">
    <button id="finalize" class="small">Finalize Connection</button>
    <button id="disconnect" class="small">Disconnect</button>
  </div>

  <div style="margin-top:8px" class="muted">Manual copy/paste signaling. No server required. STUN servers used for P2P.</div>
</div>

<div id="console"></div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.158.0/build/three.module.js';
const $ = id=>document.getElementById(id);
const log = t=>{$('console').innerText = t+"\\n"+$('console').innerText;};

// --- Scene setup ---
let renderer, scene, clock;
let players = {}, projectiles=[], bots=[], localPlayerId='p_'+Math.random().toString(36).slice(2,9), splitScreen=false, scores={};
scores[localPlayerId]=0;
let peer=null;

const container = document.getElementById('container');
renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled=true;
container.appendChild(renderer.domElement);

const camera1 = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1,2000);
const camera2 = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1,2000);

const keys={}, mouseDown=false; 
let pitch=0, yaw=0, pointerLocked=false;
scene=new THREE.Scene();
scene.background=new THREE.Color(0x0b1220);

const hemi = new THREE.HemisphereLight(0x88aaff,0x222244,0.6); scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff,0.7); dir.position.set(10,20,10); dir.castShadow=true; dir.shadow.mapSize.set(1024,1024); scene.add(dir);

const ground = new THREE.Mesh(new THREE.PlaneGeometry(120,120,40,40), new THREE.MeshStandardMaterial({color:0x23303f,roughness:0.9,metalness:0.02}));
ground.rotation.x=-Math.PI/2; ground.receiveShadow=true; scene.add(ground);

// obstacles
function makeObstacle(x,z,r=1.2,h=2,color=0x556b8a){
  const m=new THREE.Mesh(new THREE.CylinderGeometry(r,r,h,12), new THREE.MeshStandardMaterial({color}));
  m.position.set(x,h/2,z); m.castShadow=true; m.receiveShadow=true; scene.add(m); return m;
}
for(let i=0;i<25;i++){makeObstacle((Math.random()-0.5)*80,(Math.random()-0.5)*80,1+Math.random()*3,1+Math.random()*6,0x334455+Math.floor(Math.random()*0x333333));}

// --- Player ---
function createPlayer(id,isLocal=false,color=0x88ccff){
  const mesh=new THREE.Mesh(new THREE.CapsuleGeometry(0.45,1.0,4,8),new THREE.MeshStandardMaterial({color}));
  mesh.castShadow=true; mesh.position.set((Math.random()-0.5)*20,1,(Math.random()-0.5)*20); scene.add(mesh);
  players[id]={id,mesh,pos:mesh.position.clone(),rot:new THREE.Euler(),color,isLocal}; scores[id]=scores[id]||0; return players[id];
}
createPlayer(localPlayerId,true,0x99ccff);

let velocity=new THREE.Vector3(), moveSpeed=6.0, jumpStrength=6.0, canJump=true;

function updateLocalPlayer(dt){
  const p=players[localPlayerId]; if(!p)return;
  p.rot.set(p.rot.x,yaw,p.rot.z);
  const forward=new THREE.Vector3(Math.sin(yaw),0,Math.cos(yaw)).normalize();
  const right=new THREE.Vector3().crossVectors(forward,new THREE.Vector3(0,1,0)).normalize();
  let move=new THREE.Vector3();
  if(keys['KeyW'])move.add(forward); if(keys['KeyS'])move.sub(forward);
  if(keys['KeyA'])move.sub(right); if(keys['KeyD'])move.add(right);
  if(move.lengthSq()>0){move.normalize().multiplyScalar(moveSpeed*dt); p.mesh.position.add(move);}
  velocity.y-=9.8*dt; p.mesh.position.y+=velocity.y*dt;
  if(p.mesh.position.y<1){p.mesh.position.y=1; velocity.y=0; canJump=true;}
}

// --- Shooting ---
function shoot(fromId){
  const shooter=players[fromId]; if(!shooter)return;
  const dir=new THREE.Vector3(Math.sin(shooter.rot.y), Math.sin(shooter.rot.x), Math.cos(shooter.rot.y)).normalize();
  const pos=shooter.mesh.position.clone().add(new THREE.Vector3(0,0.6,0)).add(dir.clone().multiplyScalar(1.0));
  projectiles.push({pos,vel:dir.clone().multiplyScalar(35),owner:fromId,lifetime:3.0,mesh:makeProjectileMesh(pos)});
}
function makeProjectileMesh(pos){
  const mesh=new THREE.Mesh(new THREE.SphereGeometry(0.12,8,8),new THREE.MeshStandardMaterial({emissive:0xffb070,emissiveIntensity:0.7}));
  mesh.position.copy(pos); mesh.castShadow=true; scene.add(mesh); return mesh;
}
function updateProjectiles(dt){
  for(let i=projectiles.length-1;i>=0;i--){
    const p=projectiles[i]; p.lifetime-=dt;
    if(p.lifetime<=0){scene.remove(p.mesh); projectiles.splice(i,1); continue;}
    p.vel.y-=9.8*dt*0.2; p.pos.add(p.vel.clone().multiplyScalar(dt)); p.mesh.position.copy(p.pos);
    for(const id in players){
      const pl=players[id]; if(pl.mesh.position.distanceTo(p.pos)<0.8 && p.owner!==id){
        scores[p.owner]=(scores[p.owner]||0)+1; pl.mesh.position.set((Math.random()-0.5)*20,1,(Math.random()-0.5)*20);
        scene.remove(p.mesh); projectiles.splice(i,1); break;
      }
    }
  }
}

// --- Bots ---
function spawnBot(){const id='bot_'+Math.random().toString(36).slice(2,7); const bot=createPlayer(id,false,0xff7070); bots.push(id); return id;}
function updateBots(dt){for(const id of bots){const bot=players[id]; if(!bot)continue; bot.mesh.position.x+=(Math.random()-0.5)*dt*3; bot.mesh.position.z+=(Math.random()-0.5)*dt*3; if(Math.random()<dt*0.5)shoot(id); }}

// --- WebRTC Peer Fix ---
class ManualPeer{
  constructor(isOfferer=false){
    this.pc=new RTCPeerConnection({iceServers:[{urls:'stun:stun.l.google.com:19302'},{urls:'stun:stun1.l.google.com:19302'}]});
    this.dc=null; this.isConnected=false; this.onmessage=null; this.onopen=null;
    this.pc.onicecandidate=()=>{};
    this.pc.onconnectionstatechange=()=>{$('netStatus').innerText=this.pc.connectionState;};
    this.pc.ondatachannel=ev=>{this.dc=ev.channel; this.setupDC();};
    if(isOfferer){this.dc=this.pc.createDataChannel('game'); this.setupDC();}
  }
  setupDC(){if(!this.dc)return; this.dc.onopen=()=>{this.isConnected=true; log('DataChannel open'); if(this.onopen)this.onopen(); $('netStatus').innerText='connected';};
    this.dc.onclose=()=>{this.isConnected=false; log('DataChannel closed'); $('netStatus').innerText='closed';};
    this.dc.onmessage=ev=>{try{const obj=JSON.parse(ev.data); if(this.onmessage)this.onmessage(obj);}catch(e){console.warn('bad msg',e);}};
  }
  async createOffer(){await this.pc.setLocalDescription(await this.pc.createOffer()); await this._waitForIceGatheringComplete(); return this.pc.localDescription.sdp;}
  async createAnswer(remoteSdp){
    await this.pc.setRemoteDescription(new RTCSessionDescription({type:'offer',sdp:remoteSdp}));
    const ans = await this.pc.createAnswer(); await this.pc.setLocalDescription(ans);
    await this._waitForIceGatheringComplete(); return this.pc.localDescription.sdp;
  }
  async finalizeWithAnswer(answerSdp){await this.pc.setRemoteDescription(new RTCSessionDescription({type:'answer',sdp:answerSdp}));}
  async _waitForIceGatheringComplete(timeout=3000){if(this.pc.iceGatheringState==='complete')return new Promise(r=>r()); return new Promise(resolve=>{const check=()=>{if(this.pc.iceGatheringState==='complete')resolve();}; this.pc.addEventListener('icegatheringstatechange',check); setTimeout(resolve,timeout);});}
  send(obj){if(this.dc&&this.dc.readyState==='open')this.dc.send(JSON.stringify(obj));}
  close(){if(this.dc)this.dc.close(); if(this.pc)this.pc.close();}
}

// --- UI ---
$('createOffer').addEventListener('click',async()=>{
  peer=new ManualPeer(true); peer.onmessage=handleNetworkMessage; peer.onopen=()=>log('Peer open');
  const sdp=await peer.createOffer(); $('localOffer').value=sdp; log('Offer created. Copy and send to remote.');
});
$('createAnswer').addEventListener('click',async()=>{
  const remote=$('remoteOffer').value.trim(); if(!remote)return alert('Paste remote offer first.');
  peer=new ManualPeer(false); peer.onmessage=handleNetworkMessage;
  const answerSdp=await peer.createAnswer(remote); $('localOffer').value=answerSdp; log('Answer created. Copy and send back.');
});
$('finalize').addEventListener('click',async()=>{
  if(!peer)return alert('No peer.'); const ans=$('remoteAnswer').value.trim(); if(!ans)return alert('Paste remote answer.');
  await peer.finalizeWithAnswer(ans); log('Finalized connection.'); setupPeerMessaging(peer);
});
$('disconnect').addEventListener('click',()=>{if(peer){peer.close(); peer=null; $('netStatus').innerText='offline'; log('Disconnected');}});

function setupPeerMessaging(peer){
  peer.onmessage=handleNetworkMessage;
  peer.onopen=()=>{const p=players[localPlayerId]; peer.send({t:'spawn',id:localPlayerId,pos:p.mesh.position.toArray(),rot:[p.rot.x,p.rot.y,p.rot.z],color:players[localPlayerId].color});};
}
function handleNetworkMessage(obj){
  if(!obj||!obj.t)return;
  if(obj.t==='spawn'){if(!players[obj.id])createPlayer(obj.id,false,obj.color||0xffddcc); players[obj.id].mesh.position.fromArray(obj.pos); players[obj.id].rot=new THREE.Euler(obj.rot[0],obj.rot[1],obj.rot[2]); log('Remote joined: '+obj.id);}
  else if(obj.t==='state'){if(!players[obj.id])createPlayer(obj.id,false); const pl=players[obj.id]; pl.targetPos=new THREE.Vector3().fromArray(obj.pos); pl.targetRotY=obj.rotY;}
  else if(obj.t==='shoot'){const pos=new THREE.Vector3().fromArray(obj.pos); const dir=new THREE.Vector3().fromArray(obj.dir); projectiles.push({pos:pos.clone(),vel:dir.clone().multiplyScalar(35),owner:obj.id,lifetime:3.0,mesh:makeProjectileMesh(pos)});}
  else if(obj.t==='score'){scores[obj.id]=obj.score;}
}
setInterval(()=>{if(peer&&peer.isConnected){const p=players[localPlayerId]; peer.send({t:'state',id:localPlayerId,pos:p.mesh.position.toArray(),rotY:p.rot.y}); peer.send({t:'score',id:localPlayerId,score:scores[localPlayerId]});}},100);

function networkedShoot(id,origin,dir){if(peer&&peer.isConnected)peer.send({t:'shoot',id,pos:origin.toArray(),dir:dir.toArray()});}

// --- Input ---
window.addEventListener('keydown',e=>{keys[e.code]=true; if(e.code==='Space'&&canJump){velocity.y=jumpStrength;canJump=false;} if(e.code==='Tab'){e.preventDefault(); toggleSplit();}});
window.addEventListener('keyup',e=>{keys[e.code]=false;});
renderer.domElement.addEventListener('mousemove',e=>{if(!pointerLocked&&!mouseDown)return; yaw-= (e.movementX||0)*0.002; pitch-=(e.movementY||0)*0.002; pitch=Math.max(-Math.PI/2,Math.min(Math.PI/2,pitch)); players[localPlayerId].rot.x=pitch; players[localPlayerId].rot.y=yaw;});
renderer.domElement.addEventListener('mousedown',e=>{mouseDown=true; if(e.button===0){shoot(localPlayerId); const pl=players[localPlayerId]; const dir=new THREE.Vector3(Math.sin(pl.rot.y),Math.sin(pl.rot.x),Math.cos(pl.rot.y)).normalize(); const origin=pl.mesh.position.clone().add(new THREE.Vector3(0,0.6,0)).add(dir.clone().multiplyScalar(1.0)); networkedShoot(localPlayerId,origin,dir);} if(renderer.domElement.requestPointerLock)renderer.domElement.requestPointerLock();});
document.addEventListener('pointerlockchange',()=>{pointerLocked=document.pointerLockElement===renderer.domElement;});

// --- Resize ---
window.addEventListener('resize',()=>{renderer.setSize(window.innerWidth,window.innerHeight); camera1.aspect=window.innerWidth/window.innerHeight; camera1.updateProjectionMatrix(); camera2.aspect=window.innerWidth/window.innerHeight; camera2.updateProjectionMatrix();});
renderer.setSize(window.innerWidth,window.innerHeight);

// --- UI ---
$('toggleSplit').addEventListener('click',toggleSplit);
$('spawnBot').addEventListener('click',()=>{spawnBot(); log('Bot spawned');});
function toggleSplit(){splitScreen=!splitScreen; log('Split-screen: '+(splitScreen?'on':'off'));}

// --- Main loop ---
clock=new THREE.Clock();
function animate(){const dt=Math.min(0.05,clock.getDelta()); requestAnimationFrame(animate); updateLocalPlayer(dt); updateProjectiles(dt); updateBots(dt);
  for(const id in players){const p=players[id]; if(p.targetPos)p.mesh.position.lerp(p.targetPos,0.1);}
  renderer.setScissorTest(true);
  if(splitScreen){
    renderer.setViewport(0,0,window.innerWidth/2,window.innerHeight); renderer.setScissor(0,0,window.innerWidth/2,window.innerHeight); camera1.position.copy(players[localPlayerId].mesh.position).add(new THREE.Vector3(0,2,5)); camera1.lookAt(players[localPlayerId].mesh.position); renderer.render(scene,camera1);
    renderer.setViewport(window.innerWidth/2,0,window.innerWidth/2,window.innerHeight); renderer.setScissor(window.innerWidth/2,0,window.innerWidth/2,window.innerHeight); camera2.position.copy(players[localPlayerId].mesh.position).add(new THREE.Vector3(0,2,-5)); camera2.lookAt(players[localPlayerId].mesh.position); renderer.render(scene,camera2);
  } else {
    renderer.setViewport(0,0,window.innerWidth,window.innerHeight); renderer.setScissor(0,0,window.innerWidth,window.innerHeight); camera1.position.copy(players[localPlayerId].mesh.position).add(new THREE.Vector3(0,2,5)); camera1.lookAt(players[localPlayerId].mesh.position); renderer.render(scene,camera1);
  }
  renderer.setScissorTest(false);
  $('score').innerText='You: '+scores[localPlayerId];
}
animate();

</script>
<script type="module" src="https://unpkg.com/three@0.158.0/examples/jsm/controls/OrbitControls.js"></script>
</body>
</html>
